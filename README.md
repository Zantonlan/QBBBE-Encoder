# QBBBE-Encoder
An encoder (and soon to be decoder) for my audio-based byte encoding standard written entirely in C. I've only tested on Windows, but it theoretically should work on Mac and Linux.

I was faced with a strange issue during one of my various escapades. I needed to encode a megabyte of text into a wav file that was a minute long or less. I couldn't find any reasonable way to do this without buying a sound card and/or reverse engineering a pre-existing standard. I thought that a simple way to encode pretty much anything as audio would be to encode each byte as one or more samples and playing those back (the sample rate I used was the standard 44100hz). Now, this isn't very robust. It doesn't account for noise, like at all. But, if you, for example, wanted a fun little secret message thing, this would work, assuming you're sending over email, Discord, or some other platform that allows medium-sized wav uploads. This also doesn't make the files any smaller. In fact, it makes them bloat to an extreme degree. Every byte becomes 2, plus headers and stuff. That's a lot. But, I'd reckon that it could zip pretty nicely (then you could even convert *that* to a wav, as well)! I'm not quite done with the standard and might tweak it a little, but the rest of this README will outline what I have so far. Also, I haven't gotten to making a *de*coder yet. Shouldn't be too hard (knock on wood!), but it might take a minute.

## How it Works

The way this works is extremely simple. A file is split into tones, each the same length. You specify the total length in seconds of the file, so I simply divide to find the length of each tone. Each tone is a certain frequency determined by the following rules: The byte 00 is the base frequency chosen when generating the file. The byte 01 is x hz above 00, also chosen when generating the file. That difference in hz is multiplied by the byte to get the difference in hz compared to the base. For example, if your base frequency is 440hz and your step is 1hz, the byte 00 would be 440hz and 02 would be 442hz.
The file starts with three special tones. The first tone is a 00 to tell the decoder (when it exists) what the base frequency is and how long each tone will last. The second is a 01 to tell the decoder how big the step is. The third is an abnormal tone that is the base plus the length of the data in seconds times the step. These three tones together give the decoder all of the information it needs to decode the file. I was thinking of adding the file name in the "header" of this encoding format, but decided against it (at least for this iteration), as I don't think it'd really be required.
The rest of the file is a (most of the time large) collection of tones that correspond to a byte. These tones go byte-by-byte, hence the name (Quick Byte-By-Byte Encoding).

## Building

Building is extremely easy, as I didn't use any libraries and it is (for now) all in one file. To build, simply git clone the source code, then either run build.bat or make if you're on Windows, or just gcc main.c -o qbbbe-enc on Linux (I think, if you're here and using Linux, you know how).
